import QLearningUI as QL
import random


def learn(f, num):
    q_learning = QL.QLearning(5.18, 1.82, 501, 0.5, 0.9)
    for num1 in range(0, num):
        # Reset the dumbbell angle
        q_learning.ui_d_angle = 0
        # Get a random position
        position = random.random() * q_learning.num_positions * q_learning.one_pos - q_learning.max_pos
        # Make sure the position is not too small
        while abs(position) < 0.1:
            position = random.random() * q_learning.num_positions * q_learning.one_pos - q_learning.max_pos
        # Learn for 10 swings
        for num2 in range(0, 10):
            position = q_learning.perform_action(position, -1, -1, -1, 0)
            # Correct the position if it goes out of bounds
            while position > q_learning.max_pos:
                position = position - q_learning.max_pos
            while position < q_learning.min_pos:
                position = position + q_learning.max_pos

    print q_learning.q_values.astype(int)

    position = 1.3
    pos1 = position
    f.write('start, {} \n'.format(num))
    f.write('{} \n'.format(position))
    for num2 in range(0, 10):
        posindex = q_learning.index_of_state(position)
        actionpos, action = q_learning.best_action(posindex)
        position = q_learning.perform_action(position, actionpos, action, -1, 0)
        if (position == q_learning.max_pos + 1):
            break
        f.write('{} \n'.format(abs(position) - pos1))


def main():
    f = open('positions.txt', 'w')
    # Do some random learning
    """
    learn(f, 100)
    learn(f, 500)
    learn(f, 1000)
    learn(f, 5000)
    learn(f, 10000)
    """

    q_learning = QL.QLearning(5.18, 1.82, 501, 0.5, 0.9)
    for num1 in range(0, 10000):
        # Reset the dumbbell angle
        q_learning.ui_d_angle = 0
        # Get a random position
        position = random.random() * q_learning.num_positions * q_learning.one_pos - q_learning.max_pos
        # Make sure the position is not too small
        while abs(position) < 0.1:
            position = random.random() * q_learning.num_positions * q_learning.one_pos - q_learning.max_pos
        # Learn for 10 swings
        for num2 in range(0, 10):
            position = q_learning.perform_action(position, -1, -1, -1, 0)
            # Correct the position if it goes out of bounds
            while position > q_learning.max_pos:
                position = position - q_learning.max_pos
            while position < q_learning.min_pos:
                position = position + q_learning.max_pos

    print q_learning.q_values.astype(int)

    #"""
    # Show the UI implementing the learnt Q-values
    for num in range(0, 100):
        position = random.random() * q_learning.num_positions * q_learning.one_pos - q_learning.max_pos
        while position < 0.1:
            position = random.random() * q_learning.num_positions * q_learning.one_pos - q_learning.max_pos
        pos1 = position
        for num2 in range(0, 10):
            posindex = q_learning.index_of_state(position)
            actionpos, action = q_learning.best_action(posindex)
            position = q_learning.perform_action(position, actionpos, action, num, 1)
            if position == q_learning.max_pos + 1:
                break
        print abs(pos1) - abs(position)
    f.close()
    #"""
    # Show the UI implementing the learnt Q-values

    f.close()

main()
